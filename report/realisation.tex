\chapter{Offloading using Fuzzy logic}
\label{chap:fuzzy}

\section{Introduction}

Introduced in 1965 by Lotfi Zadeh\cite{zadeh-1965}, fuzzy logic is based on a "degree of truth" instead of a finite
value, usually 0 or 1, it aims to represent the vagueness of human language and thought. Fuzzy systems are the means
to implement fuzzy logic, they are two types of fuzzy systems: Mamdani and Sugeno, both are similar but differ in the
way the output is determined. The most common one Mamdani and it's the one we will be using in this project. The
Mamdani fuzzy system follows three steps:

\begin{itemize}
	\item The inputs are fuzzified into fuzzy membership functions,
	\item a set of rules are applied to the fuzzy inputs to determine the fuzzy output,
	\item the fuzzy output is defuzzified to get a crisp value.
\end{itemize}

\subsection{Fuzzification}

Fuzzification is the process of converting a crisp value into a fuzzy value, this is done by assigning a membership
function to the input value. The membership function is a curve that defines how much the input value belongs to a
certain fuzzy set. The most common membership functions are the triangular and trapezoidal functions, they are defined
by three or four parameters respectively. The triangular function is defined by the parameters $a$, $b$ and $c$ and
is given by:

\begin{equation}
	\mu(x) = \begin{cases}
		0                   & \text{if } x \leq a,        \\
		\frac{x - a}{b - a} & \text{if } a \leq x \leq b, \\
		\frac{c - x}{c - b} & \text{if } b \leq x \leq c, \\
		0                   & \text{if } x \geq c.
	\end{cases}
\end{equation}

The trapezoidal function is defined by the parameters $a$, $b$, $c$ and $d$ and is given by:

\begin{equation}
	\mu(x) = \begin{cases}
		0                   & \text{if } x \leq a,        \\
		\frac{x - a}{b - a} & \text{if } a \leq x \leq b, \\
		1                   & \text{if } b \leq x \leq c, \\
		\frac{d - x}{d - c} & \text{if } c \leq x \leq d, \\
		0                   & \text{if } x \geq d.
	\end{cases}
\end{equation}

\subsection{Rule evaluation}

The rule evaluation is the process of determining the fuzzy output based on the fuzzy inputs and a set of rules. The
rules are defined by two parts: the "if" or antecedent part and the "then" or consequent part. The antecedent part
deals with inputs, it can either be a single input or a combination of inputs, the combination can be done using the
logical operators "and" and "or". The consequent part deals with the output. In the context of this project, the rules
are usually of the form "if Bandwidth is low then processing is local". The rules are generally defined by the user
and are based on their knowledge of the system.

\subsection{Aggregation}

The aggregation is the process of combining the fuzzy outputs from the rules to get a single fuzzy output. This process
relies on T-conorms, and must satisfy the following properties:

\begin{itemize}
	\item Commutativity: $x * y = y * x$,
	\item Associativity: $x * (y * z) = (x * y) * z$,
	\item Monotony: $x \leq y \implies x * z \leq y * z$,
	\item Neutrality of 0: $x * 0 = x$ for $x \in [0, 1]$.
\end{itemize}

They are also \textit{positive reinforcement} operators:

\begin{equation}
	f(x_1, \cdots, x_n) \leq max[x_i] \forall x_i \geq 0.5
\end{equation}

As opposed to T-norms which are \textit{negative reinforcement} operators:

\begin{equation}
	f(x_1, \cdots, x_n) \geq min[x_i] \forall x_i \leq 0.5
\end{equation}

The most common T-conorms are the maximum, the probabilistic sum and the bounded sum. They are defined as follows:

\begin{minipage}{0.9685\textwidth}
	\begin{equation}
		\text{Maximum: } x \oplus y = \max(x, y)
	\end{equation}
	\begin{equation}
		\text{Probabilistic sum: } x \oplus y = x + y - x \cdot y
	\end{equation}
	\begin{equation}
		\text{Bounded sum: } x \oplus y = \min(x + y, 1)
	\end{equation}
\end{minipage}

\subsection{Defuzzification}

Defuzzification is the process of converting a fuzzy output into a crisp value, there are several methods to do this,
the most common one is the centroid method. The centroid method calculates the center of mass of the fuzzy output, this
is done by taking the weighted average of the output values. The weighted average is calculated by taking the sum of
the product of the output value and its membership value divided by the sum of the membership values. The formula for
the centroid method is given by:

\begin{equation}
	y = \frac{\sum_{i} \mu_i \cdot y_i}{\sum_{i} \mu_i}
\end{equation}

Where $y$ is the crisp output, $\mu_i$ is the membership value of the output value $y_i$. The centroid method is the
most common method because it is simple and easy to implement. However, it is not always the best method, other methods
like the mean of maximum and the largest of maximum can be used depending on the application.

\section{Fuzzy system for offloading}

\subsection{Setting up the engine}

To demonstrate the use of fuzzy logic in offloading, we wrote two simple programs in Python. The goal was to recreate
the experiment done by Hari et al.\cite{Hari-et-al-2018}. The first program uses the pyfuzzylite\cite{fuzzylite} library
to implement a fuzzy engine with all the variables and rules needed to determine the offloading decision. The second
program uses the NumPy library to generate random values for the inputs and then uses the fuzzy engine to determine
the offloading decision. The fuzzy engine is defined by the variables shown in table \ref{tab:fuzzy-input} and
\ref{tab:fuzzy-output}.

\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|c|c|}
		\hline
		Name                & Range    & Fuzzy set & Membership function & Parameters         \\
		\hline
		Bandwidth           & [0, 100] & bw_low    & trapezoidal         & 0, 20, 30, 40      \\
		(in Mbps)           &          & bw_med    & trapezoidal         & 35, 45, 60, 70     \\
		                    &          & bw_high   & trapezoidal         & 65, 75, 90, 100    \\
		\hline
		Data size           & [0, 600] & data_low  & trapezoidal         & 0, 0, 230, 360     \\
		(in KB)             &          & data_med  & trapezoidal         & 250, 350, 470, 590 \\
		                    &          & data_high & trapezoidal         & 450, 540, 600, 600 \\
		\hline
		Residual battery    & [0, 100] & bat_low   & trapezoidal         & 0, 0, 25, 35       \\
		charge (in \%)      &          & bat_med   & trapezoidal         & 25, 40, 60, 75     \\
		                    &          & bat_high  & trapezoidal         & 60, 75, 100, 100   \\
		\hline
		Load                & [0, 100] & load_low  & trapezoidal         & 0, 0, 25, 40       \\
		(in \%)             &          & load_med  & trapezoidal         & 35, 45, 60, 70     \\
		                    &          & load_high & trapezoidal         & 65, 80, 100, 100   \\
		\hline
		Memory              & [0, 100] & mem_low   & trapezoidal         & 0, 0, 25, 40       \\
		(in \%)             &          & mem_med   & trapezoidal         & 35, 45, 60, 70     \\
		                    &          & mem_high  & trapezoidal         & 65, 80, 100, 100   \\
		\hline
		Virtual machines    & [0, 50]  & vm_low    & trapezoidal         & 0, 0, 15, 20       \\
		available           &          & vm_med    & trapezoidal         & 15, 22, 37, 40     \\
		                    &          & vm_high   & trapezoidal         & 30, 35, 50, 50     \\
		\hline
		Number              & [0, 100] & user_low  & trapezoidal         & 0, 0, 25, 40       \\
		of concurrent users &          & user_med  & trapezoidal         & 30, 40, 60, 70     \\
		                    &          & user_high & trapezoidal         & 60, 75, 100, 100   \\
		\hline
	\end{tabular}
	\caption{Input variables for the fuzzy engine.}
	\label{tab:fuzzy-input}
\end{table}

\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|c|c|c|}
		\hline
		Name                & Range    & Fuzzy set & Membership function & Parameters      \\
		\hline
		Offloading decision & [0, 100] & local     & trapezoidal         & 0, 12, 24, 48   \\
		                    &          & remote    & trapezoidal         & 36, 60, 72, 100 \\
		\hline
	\end{tabular}
	\caption{Output variable for the fuzzy engine.}
	\label{tab:fuzzy-output}
\end{table}

The original paper by Hari et al. did not provide all the rules used, so we had to come up with our own rules. We
established them based on our understanding of the system and the variables. Unlike the original paper, where the
rules only combined the bandwidth with one other variable, we decided to combine the bandwidth with all the relevant
variables. The rules are shown in table \ref{tab:fuzzy-rules}.

\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{|l|l|}
			\hline
			   & Rules                                                                                                  \\
			\hline
			R1 & IF Bandwidth is bw_low                                                                                 \\
			   & THEN Processing local_processing                                                                       \\
			\hline
			R2 & IF Bandwidth is not bw_low and Datasize is not data_low                                                \\
			   & THEN Processing is remote_processing                                                                   \\
			\hline
			R3 & IF Bandwidth is not bw_low and Datasize is data_low and (Load is load_high or Memory is mem_low)       \\
			   & THEN Processing is remote_processing                                                                   \\
			\hline
			R4 & IF Bandwidth is not bw_low and Datasize is data_low and (NB_concurrent_users is user_low or Memory is
			mem_low)                                                                                                    \\
			   & THEN Processing is remote_processing                                                                   \\
			\hline
			R5 & IF Bandwidth is not bw_low and Datasize is data_low and NB_concurrent_users is not user_low and Memory
			is not mem_low and Load is load_low                                                                         \\
			   & THEN Processing is local_processing                                                                    \\
			\hline
			R6 & IF Bandwidth is not bw_low and Datasize is data_low and NB_concurrent_users is not user_low and Memory
			is not mem_low and Load is not load_low                                                                     \\
			   & THEN Processing is remote_processing                                                                   \\
			\hline
		\end{tabular}}
	\caption{Rules for the fuzzy engine.}
	\label{tab:fuzzy-rules}
\end{table}

From these rules we can see that two variables have no impact on the offloading decision, the residual battery charge
and the number of virtual machines available. So we decided to remove them from the fuzzy engine.

\subsection{Mean 3\texorpdfstring{$\Pi$}{Pi} aggregation operator (M3\texorpdfstring{$\Pi$}{Pi})}

The standard 3$\Pi$ operator was introduced by Yager and Rybalov \cite{yager-rybalov-1998} in 1988, it is a
generalization of the probabilistic sum. The 3$\Pi$ operator is defined by the following formula:

\begin{equation}
	\Pi(x_1, \cdots, x_n) = \frac{\Pi_{j=1}^n x_j}{\Pi_{j=1}^n x_j + \Pi_{j=1}^n (1 - x_j)}
\end{equation}

Unlike T-norms and T-conorms, the 3$\Pi$ operator is \textit{full reinforced} which means that it satisfies the
properties of both positive
and negative reinforcement operators.

We decided to implement a M3$\Pi$ aggregation operator which is derived from the 3$\Pi$ operator, it is defined by the
following formula:

\begin{equation}
	M3\Pi(x_1, \cdots, x_n) = \frac{\Pi_{j=1}^n (x_j)^{(1/n)}}{\Pi_{j=1}^n (x_j)^{(1/n)} + \Pi_{j=1}^n (1 - x_j)^{(1/n)}}
\end{equation}

The goal was to improve the decision-making process. However, we were unable to implement the M3$\Pi$ operator as it
would require to modify a large part of the \textit{pyfuzzylite} library. We decided to shift our focus towards other
parts of the project.

\subsection{Partial results}

Despite the lack of the M3$\Pi$ operator, we still ran the fuzzy engine with three different aggregation operators:
maximum, probabilistic sum and bounded sum. Samples of the results are shown in tables \ref{tab:fuzzy-results-max},
\ref{tab:fuzzy-results-prob} and \ref{tab:fuzzy-results-bounded}.

\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{|l|l|l|l|l|l|l|l|l|}
			\hline
			Bandwidth & Data size & Number of        & Memory & Load & Processing & Fuzzy output                                     \\
			          &           & concurrent users &        &      &            &                                                  \\
			\hline
			30        & 180       & 42               & 38     & 66   & 21.575     & 1.000/local_processing + 0.000/remote_processing \\
			77        & 462       & 44               & 96     & 8    & 67.539     & 0.000/local_processing + 1.000/remote_processing \\
			3         & 21        & 45               & 75     & 50   & 60.732     & 0.150/local_processing + 0.850/remote_processing \\
			38        & 229       & 51               & 31     & 66   & 57.565     & 0.200/local_processing + 0.600/remote_processing \\
			50        & 302       & 17               & 96     & 92   & 68.116     & 0.000/local_processing + 0.554/remote_processing \\
			\hline
		\end{tabular}}
	\caption{Sample results from the fuzzy engine with the Maximum aggregation operator.}
	\label{tab:fuzzy-results-max}

	\bigskip

	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{|l|l|l|l|l|l|l|l|l|}
			\hline
			Bandwidth & Data size & Number of        & Memory & Load & Processing & Fuzzy output                                     \\
			          &           & concurrent users &        &      &            &                                                  \\
			\hline
			30        & 180       & 42               & 38     & 66   & 21.575     & 1.000/local_processing + 0.000/remote_processing \\
			77        & 462       & 44               & 96     & 8    & 67.539     & 0.000/local_processing + 1.000/remote_processing \\
			3         & 21        & 45               & 75     & 50   & 60.443     & 0.150/local_processing + 0.850/remote_processing \\
			38        & 229       & 51               & 31     & 66   & 61.27      & 0.200/local_processing + 0.904/remote_processing \\
			50        & 302       & 17               & 96     & 92   & 68.314     & 0.000/local_processing + 0.863/remote_processing \\
			\hline
		\end{tabular}}
	\caption{Sample results from the fuzzy engine with the Probabilistic sum
		aggregation operator (note: the library calls it Algebraic sum).}
	\label{tab:fuzzy-results-prob}

	\bigskip

	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{|l|l|l|l|l|l|l|l|l|}
			\hline
			Bandwidth & Data size & Number of        & Memory & Load & Processing & Fuzzy output                                     \\
			          &           & concurrent users &        &      &            &                                                  \\
			\hline
			30        & 180       & 42               & 38     & 66   & 21.575     & 1.000/local_processing + 0.000/remote_processing \\
			77        & 462       & 44               & 96     & 8    & 67.539     & 0.000/local_processing + 1.000/remote_processing \\
			3         & 21        & 45               & 75     & 50   & 60.275     & 0.150/local_processing + 0.850/remote_processing \\
			38        & 229       & 51               & 31     & 66   & 61.855     & 0.200/local_processing + 1.000/remote_processing \\
			50        & 302       & 17               & 96     & 92   & 67.903     & 0.000/local_processing + 1.000/remote_processing \\
			\hline
		\end{tabular}}
	\caption{Sample results from the fuzzy engine with the Bounded sum aggregation operator.}
	\label{tab:fuzzy-results-bounded}
\end{table}

\section{AI-based task scheduler}